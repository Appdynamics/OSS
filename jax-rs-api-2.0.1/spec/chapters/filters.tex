\chapter{Filters and Interceptors}
\label{filters_and_interceptors}

Filters and entity interceptors can be registered for execution at well-defined extension points in \jaxrs\ implementations. They are used to extend an implementation in order to provide capabilities such as logging, confidentiality, authentication, entity compression, etc. 

\section{Introduction}
\label{introduction_filters}
Entity interceptors wrap around a method invocation at a specific extension point. 
Filters execute code at an extension point but without wrapping a method invocation.  There are four extension points for filters: \ClientRequest, \ClientResponse, \ContainerRequest\ and \ContainerResponse. There are two extension points for entity interceptors: \ReadFrom\ and \WriteTo.  For each of these extension points, there is a corresponding interface:

\begin{listing}{1}
public interface ClientRequestFilter {
    void filter(ClientRequestContext requestContext) throws IOException;
}
public interface ClientResponseFilter {
    void filter(ClientRequestContext requestContext, 
        ClientResponseContext responseContext) throws IOException;
}
public interface ContainerRequestFilter {
    void filter(ContainerRequestContext requestContext) throws IOException;
}
public interface ContainerResponseFilter {
    void filter(ContainerRequestContext requestContext, 
        ContainerResponseContext responseContext) throws IOException;
}
\end{listing}

\begin{listing}{1}
public interface ReaderInterceptor {
    Object aroundReadFrom(ReaderInterceptorContext context)
        throws java.io.IOException, javax.ws.rs.WebApplicationException;
}
public interface WriterInterceptor {
    void aroundWriteTo(WriterInterceptorContext context)
        throws java.io.IOException, javax.ws.rs.WebApplicationException;
}
\end{listing}

A {\em client} filter is a class that implements \ClientRequestFilter\ or \ClientResponseFilter\, or both. A {\em container} filter is a class that implements \ContainerRequestFilter\ or \ContainerResponseFilter, or both. An entity interceptor is a class that implements \ReaderInterceptor\ or \WriterInterceptor, or both. Filters and entity interceptors are providers and, as such, may be annotated with \Provider\ for automatic discovery.

In the Client API, a \ClientRequestFilter\ is executed as part of the invocation pipeline, before the HTTP request is delivered to the network; a \ClientResponseFilter\ is executed upon receiving a server response, before control is returned to the application. 
In the Server API, a \ContainerRequestFilter\ is executed upon receiving a request from a client; a \ContainerResponseFilter\ is executed as part of the response pipeline, before the HTTP response is delivered to the network. 

A globally-bound (see Section \ref{global_binding}) \ContainerRequestFilter\ is a container filter executed after resource matching {\em unless} it is annotated with \PreMatching. The use of this annotation on this type of filters defines a new extension point for applications to use, namely \PreMatchContainerRequest. Certain \ContainerRequestContext\ methods may not be available at this extension point. 

An entity interceptor implementing \ReaderInterceptor\ wraps around calls to \code{MessageBodyReader}'s method \code{readFrom}. An entity interceptor implementing \WriterInterceptor\ wraps around calls to \code{MessageBodyWriter}'s method \code{writeTo}. \jaxrs\ implementations are REQUIRED to call registered interceptors when mapping representations to Java types and vice versa. See Section \ref{entity_providers} for more information on entity providers.

Please refer to Appendix \ref{processing_pipeline} for some diagrams on the client and server processing pipelines that show the interaction between filters and entity interceptors.

\section{Filters}
\label{filters}

Filters are grouped into \emph{filter chains}. There is a separate filter chain for each extension point introduced in the previous section, namely: \ClientRequest, \ClientResponse, \ContainerRequest, \ContainerResponse\ and \PreMatchContainerRequest. Filters in a chain are sorted based on their priorities (see Section \ref{priorities}) and are executed in order. 

The following example shows an implementation of a container logging filter: each method simply logs the message and returns.

\begin{listing}{1}
@Provider
class LoggingFilter implements ContainerRequestFilter, 
                               ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext) 
        throws IOException {
        log(requestContext);
    }

    @Override
    public void filter(ContainerRequestContext requestContext, 
        ContainerResponseContext responseContext) throws IOException {
        log(responseContext);
    }
    ...
}
\end{listing}

\ContainerRequestContext\ is a mutable class that provides request-specific information for the filter, such as the request URI, message headers, message entity or request-scoped properties. The exposed setters allow (certain) modification of the request before it is processed by the resource method. The dual class \ContainerResponseContext\ provides response-specific information.

Request filters implementing \ClientRequestFilter\ or \ContainerRequestFilter\ can stop the execution of their corresponding chains by calling \code{abortWith(Response)} in their corresponding context object. If this method is invoked, \jaxrs\ implementations are REQUIRED to abort execution of the chain and treat the response object as if produced by calling the resource method (Server API) or executing the HTTP invocation (Client API). For example, upon a cache hit, a client {\em caching} filter may call \code{abortWith(Response)} to abort execution and optimize network access.

As stated above, a \ContainerRequestFilter\ that is annotated with \PreMatching\ is executed upon receiving a client request but {\em before} a resource method is matched. Thus, this type of filter has the ability to modify the input to the matching algorithm (see Section~\ref{request_matching}) and, consequently, alter its outcome. 
The following example uses a \ContainerRequestFilter\ annotated with \PreMatching\ to tunnel requests via POST by using the X-HTTP-Method-Override header to overwrite the HTTP method prior to resource matching.

\begin{listing}{1}
@Provider
@PreMatching
public class HttpMethodOverrideFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext) 
        throws IOException {
        if (requestContext.getMethod().equalsIgnoreCase("POST")) {
            String override = requestContext.getHeaders()
                .getFirst("X-HTTP-Method-Override");
            if (override != null) {
                requestContext.setMethod(override);
            }
        }
    }
}
\end{listing}

\section{Entity Interceptors}
\label{entity_interceptors}

An entity interceptor implements interface \ReaderInterceptor\ or \WriterInterceptor, or both. There is an \emph{interceptor chain} for each kind of entity interceptor. Entity interceptors in a chain are sorted based on their priorities (see Section \ref{priorities}) and are executed in order. 

As part of the JAX-RS processing pipeline (see Appendix \ref{processing_pipeline}), entity interceptors wrap calls to the methods \code{readFrom} in classes implementing \code{MessageBodyReader} and \code{writeTo} in classes implementing \code{MessageBodyWriter}. An interceptor SHOULD explicitly call the context method \code{proceed} to continue the execution of the chain. Because of their wrapping nature, failure to call this method will prevent execution of the wrapped method in the corresponding message body reader or message body writer.

The following example shows an implementation of a GZIP entity interceptor that provides deflate and inflate capabilities~\footnote{This class is not intended to be a complete implementation of this interceptor.}.

\begin{listing}{1}
@Provider
class GzipInterceptor implements ReaderInterceptor, WriterInterceptor {

    @Override
    Object aroundReadFrom(ReaderInterceptorContext ctx) ... {
        if (isGzipped(ctx)) {
            InputStream old = ctx.getInputStream();
            ctx.setInputStream(new GZIPInputStream(old));
            try {
                return ctx.proceed();
            } finally {
                ctx.setInputStream(old);
            }
        } else {
            return ctx.proceed();
        }
    }

    @Override
    void aroundWriteTo(WriterInterceptorContext ctx) ... {
        OutputStream old = ctx.getOutputStream();
        GZIPOutputStream gzipOutputStream = new GZIPOutputStream(old);
        ctx.setOutputStream(gzipOutputStream);
        updateHeaders(ctx);
        try {
            ctx.proceed();
        } finally {
            gzipOutputStream.finish();
            ctx.setOutputStream(old);
        }
    }
    ...
}
\end{listing}

The context types, \ReaderInterceptorContext\ and \WriterInterceptorContext, provide read and write access to the parameters of the corresponding wrapped methods. In the example shown above, the input and output streams are wrapped and updated in the context object before proceeding. \jaxrs\ implementations MUST use the last parameter values set in the context object when calling the wrapped methods \code{MessageBodyReader.readFrom} and \code{MessageBodyWriter.writeTo}.

It is worth noting that a \code{readFrom} or a \code{writeTo} that is called directly from application code, e.g.~via the injection of a \code{Providers} instance, will \emph{not} trigger the execution of any entity interceptors since it is not part of the normal JAX-RS processing pipeline. 

\section{Lifecycle}

By default, just like all the other providers, a single instance of each filter or entity interceptor is instantiated for each \jaxrs\ application. First the constructor is called, then any requested dependencies are injected, then the appropriate methods are called (simultaneously) as needed. Implementations MAY offer alternative lifecycle options beyond the default one. See Section \ref{lifecycle_and_environment} for additional information.

\section{Binding}

Binding is the process by which a filter or interceptor is associated with a resource class or method (Server API) or an invocation (Client API). The forms of binding presented in the next sections are only supported as part of the Server API. See Section \ref{binding_in_client_api} for binding in the Client API.

\subsection{Global Binding}
\label{global_binding}

Global binding is the default type of binding. A filter or interceptor that has no annotations is assumed to be bound globally, i.e.~it applies to all the resource methods in an application. Like any other provider, a filter or interceptor can be registered manually (e.g., via \code{Application} or \code{Configuration}) or be discovered automatically. Note that for a filter or interceptor to be automatically discovered it MUST be annotated with \Provider\ (see Section \ref{automatic_discovery}). 

For example, the \code{LoggingFilter} defined in Section \ref{filters} is both automatically discovered (it is annotated with \Provider) and bound globally. If this filter is part of an application, requests and responses will be logged for all resource methods. 

As stated in Section \ref{introduction_filters}, a global \ContainerRequestFilter\ is executed after resource matching unless annotated with \PreMatching. A global filter that injects \code{ResourceInfo}, and generally depends on resource information for its execution, must not be annotated with \PreMatching.

\subsection{Name Binding}
\label{Name_Binding}

A filter or interceptor can be associated with a resource class or method by declaring a new \emph{binding} annotation \`{a} la CDI~\cite{jsr299}. These annotations are declared using the \jaxrs\ meta-annotation \NameBinding\ and are used to decorate both the filter (or interceptor) and the resource method or resource class. For example, the \code{LoggingFilter} defined in Section \ref{filters} can be bound to the method \code{hello} in \code{MyResourceClass}, instead of globally, as follows:

\begin{listing}{1}
@Provider
@Logged
class LoggingFilter implements ContainerRequestFilter, 
                               ContainerResponseFilter {
    ...
}
\end{listing}

\begin{listing}{1}
@Path("/")
public class MyResourceClass {
    @Logged
    @GET
    @Produces("text/plain")
    @Path("{name}")
    public String hello(@PathParam("name") String name) {
        return "Hello " + name;
    }
}
\end{listing}

According to the semantics of \code{LoggingFilter}, the request will be logged before the \code{hello} method is called and the response will be logged after it returns. The declaration of the \code{@Logged} annotation is shown next.

\begin{listing}{1}
@NameBinding
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Logged { }
\end{listing}

Multiple filters and interceptors can be bound to a single resource method using additional annotations. For example, given the following filter:

\begin{listing}{1}
@Provider
@Authenticated
class AuthenticationFilter implements ContainerRequestFilter {
    ...
}
\end{listing}

method \code{hello} above could be decorated with \code{@Logged} and \code{@Authenticated} in order to provide both logging and authentication capabilities to the resource.

A filter or interceptor class can be decorated with multiple binding annotations. In this case, in accordance with the semantics described in CDI~\cite{jsr299}, all those annotations must be present in the resource class or method for the binding to be established. For example, if \code{LoggingFilter} is defined as follows:

\begin{listing}{1}
@Provider
@Logged @Verbose
class LoggingFilter implements ContainerRequestFilter, 
                               ContainerResponseFilter {
    ...
}
\end{listing}

then method \code{hello} above must be annotated with both \code{@Logged} and \code{@Verbose} for the binding to be in effect.

Binding annotations can also be applied to resource classes and  \code{Application} subclasses. Binding annotations that decorate resource classes apply to \emph{all} resource methods defined in them. 
Binding annotations that decorate \code{Application} subclasses can also be used to bind filters and interceptors globally, even if other annotations are present. For example, \code{LoggingFilter} as defined at the beginning of this section can be bound globally as follows:

\begin{listing}{1}
@Logged
public class MyApplication extends Application {
    ...
}
\end{listing}

Note that returning filters or interceptors from the methods \code{getClasses} or \code{getSingletons} in an application subclass will bind them globally only if they are \emph{not} decorated with a name binding annotation. If they are decorated with at least one name binding annotation, the application subclass must be annotated as shown above in order for those filters or interceptors to be bound globally. See Chapter \ref{applications} for more information on \jaxrs\ applications.

\subsection{Dynamic Binding}
\label{dynamic_binding}

The annotation-based forms of binding presented thus far are {\em static}. Dynamic binding is also supported using dynamic features. A dynamic feature is a provider that implements the \DynamicFeature\ interface. These providers are used to augment the set of filters and entity interceptors bound to a resource method. 

The following example defines a dynamic feature that binds the filter \code{LoggingFilter} ---assumed not globally bound for the purpose of this example--- with all the resource methods in \code{MyResource} that are annotated with \code{@GET}.

\begin{listing}{1}
@Provider
public class DynamicLoggingFilterFeature implements DynamicFeature {

  @Override
  void configure(ResourceInfo resourceInfo, Configuration config) {
    if (MyResource.class.isAssignableFrom(resourceInfo.getResourceClass())
      && resourceInfo.getResourceMethod().isAnnotationPresent(GET.class)) {
      config.register(new LoggingFilter());
    }
  }
}

\end{listing}

The overridden method in this provider updates the \code{Configuration} object assigned to each resource method; the information about the resource method is provided in the form of a \code{ResourceInfo} instance.
\jaxrs\ implementations SHOULD resolve dynamic features for filters and interceptors once for each resource method. It is RECOMMENDED to process dynamic features at application deployment time.

\subsection{Binding in Client API}
\label{binding_in_client_api}

Binding in the Client API is accomplished via API calls instead of annotations. \Client, \Invocation, \InvocationBuilder\ and \WebTarget\ are all configurable types: their configuration can be accessed using the methods inherited from the \code{Configurable} interface. See Section \ref{configurable_types} for more information.

\section{Priorities}
\label{priorities}

The order in which filters and interceptors are executed as part of their corresponding chains is controlled by the \Priority\ annotation defined in \cite{jsr250}.
Priorities are represented by integer numbers. Execution chains for extension points \ContainerRequest, \PreMatchContainerRequest, \ClientRequest, \ReadFrom\ and \WriteTo\ are sorted in \emph{ascending order}; the lower the number the higher the priority. Execution chains for extension points \ContainerResponse\ and \ClientResponse\ are sorted in \emph{descending order}; the higher the number the higher the priority. These rules ensure that response filters are executed in reversed order of request filters.

The \code{Priorities} class in JAX-RS defines a set of built-in priorities for security, header decorators, decoders and encoders. The default binding priority is \code{Priorities.USER}. For example, the priority of an authentication filter can be set as follows:

\begin{listing}{1}
@Provider
@Authenticated
@Priority(Priorities.AUTHENTICATION)
public class AuthenticationFilter implements ContainerRequestFilter {
    ...
}
\end{listing}

Note that even though, as explained in Section \ref{binding_in_client_api}, annotations are not used for binding in the Client API, they are still used to define priorities. Therefore, if a priority other than the default is required, the \Priority\ annotation must be used for a filter or interceptor registered with the Client API. 

The order in which filters and interceptors that belong to the same priority class are executed is implementation dependent.

\section{Exceptions}
\label{exceptions_filters_and_interceptors}

\subsection{Server Runtime}

When a filter or interceptor method throws an exception, the server runtime will process the exception as described in Section \ref{exceptions_providers_server}. As explained in Section \ref{exceptionmapper}, an application can supply exception mapping providers. At most one exception mapper MUST be used in a single request processing cycle to avoid potentially infinite loops. 

A response mapped from an exception MUST be processed using the \ContainerResponse\ filter chain and the \WriteTo\ interceptor chain (if an entity is present in the mapped response). The number of entries in these chains depends on whether a resource method has been matched or not at the time the exception is thrown. There are two cases:

\begin{enumerate}
\item If a web resource has been matched before the exception was thrown, then the filters in \ContainerResponse\ and the interceptors in \WriteTo\ will include everything that has been bound to the method as well as globally;
\item\label{no_matching} Otherwise, only global filters and interceptors will be included.
\end{enumerate}

Note that a filter or interceptor invoked in case \ref{no_matching} will not have access to resource-dependent information, such as that returned by an injectable instance of \code{ResourceInfo}.

\subsection{Client Runtime}

When a filter or interceptor method throws an exception, the client runtime will process the exception as described in Section \ref{exceptions_providers_client}.

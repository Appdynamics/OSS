//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.02.10 at 11:20:59 AM CST 
//


package org.hibernate.boot.jaxb.hbm.spi;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.hibernate.org/xsd/orm/hbm}ToolingHintContainer"&gt;
 *       &lt;choice maxOccurs="unbounded"&gt;
 *         &lt;element name="identifier-generator" type="{http://www.hibernate.org/xsd/orm/hbm}IdentifierGeneratorDefinitionType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="typedef" type="{http://www.hibernate.org/xsd/orm/hbm}TypeDefinitionType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="filter-def" type="{http://www.hibernate.org/xsd/orm/hbm}FilterDefinitionType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="import" type="{http://www.hibernate.org/xsd/orm/hbm}ClassRenameType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="class" type="{http://www.hibernate.org/xsd/orm/hbm}RootEntityType"/&gt;
 *         &lt;element name="subclass" type="{http://www.hibernate.org/xsd/orm/hbm}DiscriminatorSubclassEntityType"/&gt;
 *         &lt;element name="joined-subclass" type="{http://www.hibernate.org/xsd/orm/hbm}JoinedSubclassEntityType"/&gt;
 *         &lt;element name="union-subclass" type="{http://www.hibernate.org/xsd/orm/hbm}UnionSubclassEntityType"/&gt;
 *         &lt;element name="resultset" type="{http://www.hibernate.org/xsd/orm/hbm}ResultSetMappingType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;group ref="{http://www.hibernate.org/xsd/orm/hbm}NamedQueryGroup" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="fetch-profile" type="{http://www.hibernate.org/xsd/orm/hbm}FetchProfileType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="database-object" type="{http://www.hibernate.org/xsd/orm/hbm}AuxiliaryDatabaseObjectType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/choice&gt;
 *       &lt;attribute name="auto-import" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" /&gt;
 *       &lt;attribute name="catalog" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;attribute name="default-access" type="{http://www.w3.org/2001/XMLSchema}string" default="property" /&gt;
 *       &lt;attribute name="default-cascade" type="{http://www.w3.org/2001/XMLSchema}string" default="none" /&gt;
 *       &lt;attribute name="default-lazy" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" /&gt;
 *       &lt;attribute name="package" type="{http://www.hibernate.org/xsd/orm/hbm}ClassNameType" /&gt;
 *       &lt;attribute name="schema" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "identifierGenerator",
    "typedef",
    "filterDef",
    "_import",
    "clazz",
    "subclass",
    "joinedSubclass",
    "unionSubclass",
    "resultset",
    "query",
    "sqlQuery",
    "fetchProfile",
    "databaseObject"
})
@XmlRootElement(name = "hibernate-mapping")
public class JaxbHbmHibernateMapping
    extends JaxbHbmToolingHintContainer
    implements Serializable
{

    @XmlElement(name = "identifier-generator")
    protected List<JaxbHbmIdentifierGeneratorDefinitionType> identifierGenerator;
    protected List<JaxbHbmTypeDefinitionType> typedef;
    @XmlElement(name = "filter-def")
    protected List<JaxbHbmFilterDefinitionType> filterDef;
    @XmlElement(name = "import")
    protected List<JaxbHbmClassRenameType> _import;
    @XmlElement(name = "class")
    protected List<JaxbHbmRootEntityType> clazz;
    protected List<JaxbHbmDiscriminatorSubclassEntityType> subclass;
    @XmlElement(name = "joined-subclass")
    protected List<JaxbHbmJoinedSubclassEntityType> joinedSubclass;
    @XmlElement(name = "union-subclass")
    protected List<JaxbHbmUnionSubclassEntityType> unionSubclass;
    protected List<JaxbHbmResultSetMappingType> resultset;
    protected List<JaxbHbmNamedQueryType> query;
    @XmlElement(name = "sql-query")
    protected List<JaxbHbmNamedNativeQueryType> sqlQuery;
    @XmlElement(name = "fetch-profile")
    protected List<JaxbHbmFetchProfileType> fetchProfile;
    @XmlElement(name = "database-object")
    protected List<JaxbHbmAuxiliaryDatabaseObjectType> databaseObject;
    @XmlAttribute(name = "auto-import")
    protected Boolean autoImport;
    @XmlAttribute(name = "catalog")
    protected String catalog;
    @XmlAttribute(name = "default-access")
    protected String defaultAccess;
    @XmlAttribute(name = "default-cascade")
    protected String defaultCascade;
    @XmlAttribute(name = "default-lazy")
    protected Boolean defaultLazy;
    @XmlAttribute(name = "package")
    protected String _package;
    @XmlAttribute(name = "schema")
    protected String schema;

    /**
     * Gets the value of the identifierGenerator property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the identifierGenerator property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIdentifierGenerator().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmIdentifierGeneratorDefinitionType }
     * 
     * 
     */
    public List<JaxbHbmIdentifierGeneratorDefinitionType> getIdentifierGenerator() {
        if (identifierGenerator == null) {
            identifierGenerator = new ArrayList<JaxbHbmIdentifierGeneratorDefinitionType>();
        }
        return this.identifierGenerator;
    }

    /**
     * Gets the value of the typedef property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the typedef property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTypedef().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmTypeDefinitionType }
     * 
     * 
     */
    public List<JaxbHbmTypeDefinitionType> getTypedef() {
        if (typedef == null) {
            typedef = new ArrayList<JaxbHbmTypeDefinitionType>();
        }
        return this.typedef;
    }

    /**
     * Gets the value of the filterDef property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the filterDef property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFilterDef().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmFilterDefinitionType }
     * 
     * 
     */
    public List<JaxbHbmFilterDefinitionType> getFilterDef() {
        if (filterDef == null) {
            filterDef = new ArrayList<JaxbHbmFilterDefinitionType>();
        }
        return this.filterDef;
    }

    /**
     * Gets the value of the import property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the import property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getImport().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmClassRenameType }
     * 
     * 
     */
    public List<JaxbHbmClassRenameType> getImport() {
        if (_import == null) {
            _import = new ArrayList<JaxbHbmClassRenameType>();
        }
        return this._import;
    }

    /**
     * Gets the value of the clazz property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the clazz property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getClazz().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmRootEntityType }
     * 
     * 
     */
    public List<JaxbHbmRootEntityType> getClazz() {
        if (clazz == null) {
            clazz = new ArrayList<JaxbHbmRootEntityType>();
        }
        return this.clazz;
    }

    /**
     * Gets the value of the subclass property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subclass property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubclass().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmDiscriminatorSubclassEntityType }
     * 
     * 
     */
    public List<JaxbHbmDiscriminatorSubclassEntityType> getSubclass() {
        if (subclass == null) {
            subclass = new ArrayList<JaxbHbmDiscriminatorSubclassEntityType>();
        }
        return this.subclass;
    }

    /**
     * Gets the value of the joinedSubclass property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the joinedSubclass property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getJoinedSubclass().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmJoinedSubclassEntityType }
     * 
     * 
     */
    public List<JaxbHbmJoinedSubclassEntityType> getJoinedSubclass() {
        if (joinedSubclass == null) {
            joinedSubclass = new ArrayList<JaxbHbmJoinedSubclassEntityType>();
        }
        return this.joinedSubclass;
    }

    /**
     * Gets the value of the unionSubclass property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the unionSubclass property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getUnionSubclass().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmUnionSubclassEntityType }
     * 
     * 
     */
    public List<JaxbHbmUnionSubclassEntityType> getUnionSubclass() {
        if (unionSubclass == null) {
            unionSubclass = new ArrayList<JaxbHbmUnionSubclassEntityType>();
        }
        return this.unionSubclass;
    }

    /**
     * Gets the value of the resultset property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the resultset property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getResultset().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmResultSetMappingType }
     * 
     * 
     */
    public List<JaxbHbmResultSetMappingType> getResultset() {
        if (resultset == null) {
            resultset = new ArrayList<JaxbHbmResultSetMappingType>();
        }
        return this.resultset;
    }

    /**
     * Gets the value of the query property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the query property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQuery().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmNamedQueryType }
     * 
     * 
     */
    public List<JaxbHbmNamedQueryType> getQuery() {
        if (query == null) {
            query = new ArrayList<JaxbHbmNamedQueryType>();
        }
        return this.query;
    }

    /**
     * Gets the value of the sqlQuery property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sqlQuery property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSqlQuery().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmNamedNativeQueryType }
     * 
     * 
     */
    public List<JaxbHbmNamedNativeQueryType> getSqlQuery() {
        if (sqlQuery == null) {
            sqlQuery = new ArrayList<JaxbHbmNamedNativeQueryType>();
        }
        return this.sqlQuery;
    }

    /**
     * Gets the value of the fetchProfile property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fetchProfile property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFetchProfile().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmFetchProfileType }
     * 
     * 
     */
    public List<JaxbHbmFetchProfileType> getFetchProfile() {
        if (fetchProfile == null) {
            fetchProfile = new ArrayList<JaxbHbmFetchProfileType>();
        }
        return this.fetchProfile;
    }

    /**
     * Gets the value of the databaseObject property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the databaseObject property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDatabaseObject().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JaxbHbmAuxiliaryDatabaseObjectType }
     * 
     * 
     */
    public List<JaxbHbmAuxiliaryDatabaseObjectType> getDatabaseObject() {
        if (databaseObject == null) {
            databaseObject = new ArrayList<JaxbHbmAuxiliaryDatabaseObjectType>();
        }
        return this.databaseObject;
    }

    /**
     * Gets the value of the autoImport property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAutoImport() {
        if (autoImport == null) {
            return true;
        } else {
            return autoImport;
        }
    }

    /**
     * Sets the value of the autoImport property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAutoImport(Boolean value) {
        this.autoImport = value;
    }

    /**
     * Gets the value of the catalog property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Sets the value of the catalog property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setCatalog(String value) {
        this.catalog = value;
    }

    /**
     * Gets the value of the defaultAccess property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultAccess() {
        if (defaultAccess == null) {
            return "property";
        } else {
            return defaultAccess;
        }
    }

    /**
     * Sets the value of the defaultAccess property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultAccess(String value) {
        this.defaultAccess = value;
    }

    /**
     * Gets the value of the defaultCascade property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultCascade() {
        if (defaultCascade == null) {
            return "none";
        } else {
            return defaultCascade;
        }
    }

    /**
     * Sets the value of the defaultCascade property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultCascade(String value) {
        this.defaultCascade = value;
    }

    /**
     * Gets the value of the defaultLazy property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isDefaultLazy() {
        if (defaultLazy == null) {
            return true;
        } else {
            return defaultLazy;
        }
    }

    /**
     * Sets the value of the defaultLazy property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setDefaultLazy(Boolean value) {
        this.defaultLazy = value;
    }

    /**
     * Gets the value of the package property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getPackage() {
        return _package;
    }

    /**
     * Sets the value of the package property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setPackage(String value) {
        this._package = value;
    }

    /**
     * Gets the value of the schema property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Sets the value of the schema property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSchema(String value) {
        this.schema = value;
    }

}
